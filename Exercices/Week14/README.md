## Задача 1
Да се дефинира функция getClosestPoint, която приема списък от точки и още една точка p. 
Като резултат функцията да връща тази точка от списъка, която е най-близо до точката p.

## Задача 2
Да се дефинират рекурсивен алгебричен тип двоично дърво (BTree) и следните функции:

a) функция size, която намира броя на елементите на двоично дърво

b) функция height, която намира височината на двоично дърво

c) функция sumTree, която намира сумата от елементите на двоично дърво

d) функция sumLeaves, която намира сумата елементите по листата на двоично дърво

e) функция inorder, която обхожда двоично дърво в ред Ляво-Корен-Дясно

Примери:
```haskell
t1 :: BTree                                --    5
t1 = Node 5 (Node 2 Empty                  --   / \
                    (Node 3 Empty Empty))  --  2   6
            (Node 6 Empty Empty)           --   \
                                           --    3 
                                          
t2 :: BTree                                --    5
t2 = Node 5 (Node 3 Empty Empty)           --   / \
            (Node 4 (Node 5 Empty Empty)   --  3   4
                    (Node 7 Empty Empty))  --     /  \
                                           --    5    7
```
## Задача 3
Да се дефинира функция getLevel :: Int -> BTree -> [Int], която намира елементите на k-то ниво на двоично дърво.

## Задача 4
Да се дефинира функция average :: BTree -> Double, която пресмята средно-аритметичното от записаното във върховете на двоично дърво.

## Задача 5
Да се дефинира функция mirrorTree :: BTree -> BTree, която преобразува дърво в "огледалното" му.

Пример:  
```
     1               1
    / \             / \
  2    3     =>    3   2
 /    /  \        / \   \
5    7   6       6   7   5
```
